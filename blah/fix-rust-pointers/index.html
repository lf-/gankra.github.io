<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust's Unsafe Pointer Types Need An Overhaul - Faultlore</title></title>

    
    <link href="../rust.css" rel="stylesheet" type="text/css">
<link href="../style.css" rel="stylesheet" type="text/css">

<meta name="author" content="Aria Beingessner">
<meta property="og:image" content="https://gankra.github.io/blah/img/error-base.png">
<meta property="og:type" content="article">

<meta property="og:title" content="Rust's Unsafe Pointer Types Need An Overhaul - Faultlore">
<meta property="og:url" content="https://gankra.github.io/blah/fix-rust-pointers">

</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <link href="../header.css" rel="stylesheet" type="text/css">

<header id="title-bar">
    <div id = "logo">
        <a id="logo" href="../">
            <img src="../img/error-glitch.png"/>
        </a>
    </div>
    
    <h1 id="title">
        <div id="title-layer1" class="layer">
            Faultlore
            <div id="title-layer2" class="layer">
                Faultlore
                <div id="title-layer3" class="layer">
                    Faultlore
                </div>
            </div>
        </div>
    </h1>
</header>

<article class="content">

    <h1 class="title">Rust&#39;s Unsafe Pointer Types Need An Overhaul</h1>
    <header>
    <p class="author">Aria Beingessner</p>
    <p class="date">March 19th, 2022</p>
<nav id="TOC"><ul>
<li><a href="#background">1 Background</a><ul>
<li><a href="#aliasing">1.1 Aliasing</a><ul></ul></li>
<li><a href="#alias-analysis-and-pointer-provenance">1.2 Alias Analysis and Pointer Provenance</a><ul></ul></li>
<li><a href="#cheri">1.3 CHERI</a><ul></ul></li></ul></li>
<li><a href="#problems">2 Problems</a><ul>
<li><a href="#integer-to-pointer-casts-are-the-devil">2.1 Integer-To-Pointer Casts Are The Devil</a><ul></ul></li>
<li><a href="#references-make-really-strong-assertions">2.2 References Make Really Strong Assertions</a><ul></ul></li>
<li><a href="#offsets-and-places-are-a-mess">2.3 Offsets And Places Are A Mess</a><ul></ul></li></ul></li>
<li><a href="#solutions">3 Solutions</a><ul>
<li><a href="#distinguish-pointers-and-addresses">3.1 Distinguish Pointers And Addresses</a><ul>
<li><a href="#redefining-usize">3.1.1 Redefining usize</a><ul></ul></li>
<li><a href="#replacing-pointer-integer-casts">3.1.2 Replacing Pointer-Integer Casts</a><ul></ul></li></ul></li>
<li><a href="#fixing-places-and-offsets">3.2 Fixing Places and Offsets</a><ul>
<li><a href="#path-offset-syntax">3.2.1 Path Offset Syntax</a><ul></ul></li>
<li><a href="#postfix-deref">3.2.2 Postfix Deref</a><ul></ul></li></ul></li></ul></li>
<li><a href="#thats-all">4 That‚Äôs All!</a><ul></ul></li></ul></nav></header>
<p>I think about unsafe pointers in Rust a lot.</p>
<p>I literally wrote the book on <a href="https://doc.rust-lang.org/nightly/nomicon/">unsafe Rust</a>. And the book on <a href="https://rust-unofficial.github.io/too-many-lists/">pointers in Rust</a>. And <a href="https://github.com/rust-lang/rfcs/blob/master/text/1966-unsafe-pointer-reform.md">redesigned the Rust‚Äôs pointer APIs</a>. And designed the standard library‚Äôs <a href="https://github.com/rust-lang/rust/pull/26955">abstraction for unsafe heap-allocated buffers</a>. And maintain <a href="https://github.com/Gankra/thin-vec/">the alternative Vec layout</a>.</p>
<p>I think about unsafe pointers in Rust <em>a lot</em>, and I absolutely hate them.</p>
<p>Don‚Äôt get me wrong, I think all of the above work has made them <em>better</em> but they are still deeply flawed. Actually they‚Äôve gotten a lot <em>worse</em>. Not because the APIs have changed, but because when I was working on this stuff we had too <em>naive</em> of an understanding of how pointers should work. Others have done a lot of great work to expand this understanding, and now the flaws are all the more glaring.</p>
<p>This article is broken up into 3 parts: conceptual background, problems with the current design, and proposed solutions.</p>
<h1 id="background" class="section-header"><a href="#background">1 Background</a></h1>
<p>This section can be skipped entirely if you know everything about computers.</p>
<h2 id="aliasing" class="section-header"><a href="#aliasing">1.1 Aliasing</a></h2>
<p><a href="https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html">Aliasing</a> is a <a href="https://doc.rust-lang.org/nightly/nomicon/aliasing.html">very important concept</a> in compilers and language semantics. At a high-level, it‚Äôs the study of the <em>observability</em> of modifications to memory. We call it <em>aliasing</em> because the problem is very easy until you can refer to a piece of memory in more than one way. Pointers are just nicknames for memory.</p>
<p>The primary function of aliasing is as a model for when the compiler can semantically cache memory accesses. This can either mean assuming a value in memory hasn‚Äôt been modified <em>or</em> assuming a write to memory isn‚Äôt necessary. This is exceptionally important because <em>essentially all program state is semantically in memory</em>. It‚Äôs impossible for a general purpose programming language that does <em>anything</em> on the behalf of the programmer to allow arbitrary reads and writes to memory.</p>
<p>As a hopefully extremely obvious example that we can all agree on, a compiler should be able to assume that the following program will pass <code>1</code> to <code>println!</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">0</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">y</span> <span class="op">=</span> <span class="number">1</span>;

<span class="comment">// Wouldn&#39;t it be fucked up if this could modify y?</span>
<span class="ident">x</span> <span class="op">=</span> <span class="number">2</span>;

<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">y</span>);</code></pre></div>
<p>When we talk about aliasing we usually jump immediately to pointers because that‚Äôs the hard part but like, the fact that this has deterministic behaviour is part of your aliasing model! Variables are semantically unaliased until you actually take a reference to them!</p>
<p>This is actually a foundational assumption for putting things in registers, because putting something in a register is caching it. If a compiler can‚Äôt decide it‚Äôs ok to put values in general purpose registers or spill them to the stack, it‚Äôs an assembler <em>at best</em>. We would like to build languages that are higher-level than an assembler!</p>
<p>With the ‚Äúno really you need this no matter what‚Äù part out of the way, let‚Äôs talk about how pointers make this hard. In the following function, can we assume that <code>input</code> and <code>output</code> refer to different regions of memory?</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">compute</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">u32</span>, <span class="ident">output</span>: <span class="kw-2">&amp;mut</span> <span class="ident">u32</span>) {
    <span class="kw">if</span> <span class="kw-2">*</span><span class="ident">input</span> <span class="op">&gt;</span> <span class="number">10</span> {
        <span class="kw-2">*</span><span class="ident">output</span> <span class="op">=</span> <span class="number">1</span>;
    }
    <span class="kw">if</span> <span class="kw-2">*</span><span class="ident">input</span> <span class="op">&gt;</span> <span class="number">5</span> {
        <span class="kw-2">*</span><span class="ident">output</span> <span class="kw-2">*</span><span class="op">=</span> <span class="number">2</span>;
    }
}</code></pre></div>
<p>If we can, then the compiler is free to rewrite it as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">compute</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">u32</span>, <span class="ident">output</span>: <span class="kw-2">&amp;mut</span> <span class="ident">u32</span>) {
    <span class="comment">// keep `*input` in a register</span>
    <span class="kw">let</span> <span class="ident">cached_input</span> <span class="op">=</span> <span class="kw-2">*</span><span class="ident">input</span>; 
    <span class="kw">if</span> <span class="ident">cached_input</span> <span class="op">&gt;</span> <span class="number">10</span> {
        <span class="comment">// If the original, &gt; 10 would imply:</span>
        <span class="comment">//</span>
        <span class="comment">// *output = 1</span>
        <span class="comment">// *output *= 2</span>
        <span class="comment">//</span>
        <span class="comment">// which we can just simplify into:</span>
        <span class="kw-2">*</span><span class="ident">output</span> <span class="op">=</span> <span class="number">2</span>;
    } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">cached_input</span> <span class="op">&gt;</span> <span class="number">5</span> {
        <span class="kw-2">*</span><span class="ident">output</span> <span class="kw-2">*</span><span class="op">=</span> <span class="number">2</span>;
    }
}</code></pre></div>
<p>If they <em>do</em> point to overlapping memory, then the write <code>*output = 1</code> would affect the result of the read <code>*input &gt; 5</code>, and we say those accesses <em>alias</em>. When we perform (potentially) aliasing accesses, the compiler has to conservatively load and store from memory as much as the source code implies.</p>
<p>Now it‚Äôs often clumsy to talk about <em>accesses</em> aliasing, so we usually talk about <em>pointers</em>aliasing as a shorthand. So one would reasonably say that <code>input</code> and <code>output</code> alias each other. The reason that the <em>actual</em> model is in terms of <em>accesses</em> and not <em>pointers</em> is because that‚Äôs the thing that we care about.</p>
<p>We don‚Äôt <em>actually</em> care if you pass in two pointers that ‚Äúalias‚Äù but:</p>
<ul>
<li>Only one of them is ever used (no second observer)</li>
<li>Both only read (a read can‚Äôt observably affect another read) (this assumption is why memory mapped hardware has to use <code>volatile</code>)</li>
</ul>
<p>This is also why Rust has such a distinct schism between ‚Äúunique mutable‚Äù references (<code>&amp;mut</code>) and ‚Äúshared immutable‚Äù references (<code>&amp;</code>). It‚Äôs fine to make as many copies as you want of readonly pointers, but if you want to actually write to memory it‚Äôs really important to know how it‚Äôs aliased!</p>
<p>(You may notice that this is a simplified model full of lies, if you would like less lies, read my extremely detailed <a href="https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html">discussion of Stacked Borrows</a>.)</p>
<p>Here are some other useful shorthands: </p>
<ul>
<li>memory is <strong>anonymous</strong> if the programmer cannot refer to it by name or pointer.</li>
<li>memory is <strong>unaliased</strong> if there is currently only one way to refer to it.</li>
</ul>
<p>Anonymous memory is in some sense ‚Äúcompletely under the control of the compiler‚Äù and can therefore be freely assumed to be unaliased and trusted/modified by the compiler. Unaliased memory cannot be ‚Äúrandomly‚Äù modified by something seemingly ‚Äúunrelated‚Äù (we‚Äôll get to what that means in the next section).</p>
<p>Languages can have <em>stricter</em> or <em>weaker</em> aliasing models. A stricter model allows the compiler to do more optimizations but puts heavier restrictions on what the programmer is allowed to do within the confines of the language. Here are some common rules, in vaguely increasing strictness:</p>
<ul>
<li>Callee-saved values pushed to the stack are anonymous (return pointer, frame pointer).</li>
<li>‚ÄúScratch‚Äù values the compiler spills to the stack are anonymous.</li>
<li>A newly declared variable is unaliased until a reference is taken to it.</li>
<li>The memory returned by <code>malloc</code> is unaliased.</li>
<li>Fields of a struct do not alias eachother (bitfields are made of sadness).</li>
<li>Padding bytes are vaguely anonymous (messy because of memcpy/memset/unions/punning).</li>
<li>Immutable variables are functionally unaliased in that they can never change values.</li>
<li>In Rust, <code>&amp;mut</code> is unaliased (<a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/">Stacked Borrows</a>).</li>
<li>In C(++), <code>T*</code> and <code>U*</code> cannot alias if <code>T!=U</code> and neither is <code>char</code> (<a href="https://blog.regehr.org/archives/1307">Strict Aliasing</a>).</li>
</ul>
<p>(I cannot emphasize enough how shorthanded all of this is, the devil is extremely in the details and formally specifying these things is this subject of untold numbers of PhD theses. I am not trying to write a PhD thesis right now. Unless you literally work on a C/C++ Standard Committee or are named Ralf Jung I will not be accepting your Umm Actually‚Äôs on these definitions and terms.)</p>
<h2 id="alias-analysis-and-pointer-provenance" class="section-header"><a href="#alias-analysis-and-pointer-provenance">1.2 Alias Analysis and Pointer Provenance</a></h2>
<p>Ok so you have some definitions for how memory can be considered ‚Äúunaliased‚Äù, but as soon as you take a pointer to something, or copy a pointer, or offset a pointer‚Ä¶ that all goes out the window, right? Like you have to assume anything can be aliased by anything else?</p>
<p>No! Aliasing rules are some of the most foundational parts of a language‚Äôs semantics and optimizations. If you run afoul of the language‚Äôs aliasing rules you have Undefined Behaviour and the miscompilations can be extremely brutal!</p>
<p>But yes, once you start faffing around with pointers things get <em>a lot harder</em> for the compiler, memory model, and programmer. To make aliasing a useful notion once pointers start getting thrown around, memory models very quickly find the need to define two concepts:</p>
<ul>
<li>Allocations</li>
<li>Pointer Provenance</li>
</ul>
<p><em>Allocations</em> abstractly describe things like individual variables and heap allocations. A freshly created allocation (variable decl, malloc) is always brought into the world unaliased and therefore acts like a <em>sandbox</em> with One True Name ‚Äì there is no way to access the memory in the sandbox <em>except</em> through the One True Name (that isn‚Äôt Undefined Behaviour).</p>
<p>Permission to access the allocation‚Äôs sandbox can be <em>delegated</em> from the One True Name by deriving a new pointer from it (or anything recursively derived from it). The process of tracking this ‚Äúchain of custody‚Äù from the One True Name to all of its derived pointers is <em>Pointer Provenance</em>.</p>
<p>From a formal memory model perspective, all accesses to an allocation must have <em>provenance</em> tracking back to that allocation. If pointer provenance isn‚Äôt satisfied, then that means the programmer broke out of the sandbox or pulled a pointer from the aether that happened to point into some random sandbox. Either way, everything is chaos and nothing makes sense anymore if that‚Äôs allowed.</p>
<p>From a compiler optimization perspective, tracking provenance allows the compiler to prove that two accesses don‚Äôt alias. If two pointers are known to have different provenance, then they cannot possibly alias and you can get Good Codegen. If it ever loses track of a pointer to some memory (i.e. if pointers are passed to an opaque function) then it has put that memory/pointer in a ‚Äúmay be aliased‚Äù bucket. Accesses through two may-be-aliased sources have to conservatively be assumed to alias and can get Bad Codegen.</p>
<p>This is the fundamental trick compilers apply to all impossible problems: have a simple analysis that can answer your query with ‚ÄúYES‚Äù, ‚ÄúNO‚Äù, or ‚ÄúMAYBE‚Äù and then convert ‚ÄúMAYBE‚Äù to ‚ÄúYES‚Äù or ‚ÄúNO‚Äù based on whichever one is safer. Do these two accesses MAYBE alias? Then YES they alias. Problem Solved.</p>
<p>In a memory-safe language, this is all ‚Äújust‚Äù an optimization scheme because the programmer can‚Äôt ‚Äúbreak‚Äù the compiler‚Äôs analysis. But once you‚Äôre doing unsafe things (like with C or Unsafe Rust), the compiler needs you to help it out and actually follow some dang rules. Specifically, everyone agrees you <em>really</em> shouldn‚Äôt be allowed to break out of allocation sandboxes.</p>
<p>This is why llvm‚Äôs <a href="https://llvm.org/docs/GetElementPtr.html">GetElementPointer (GEP)</a> instruction, which computes a pointer offset, is almost always emitted by compilers with the <code>inbounds</code> keyword. The <code>inbounds</code> keyword is basically ‚ÄúI promise this offset won‚Äôt break the pointer out of its allocation sandbox and completely trash aliasing and provenance‚Äù. Which like, yeah all of your pointer offsets should follow that rule!</p>
<p>Let‚Äôs go up a level and look at rustc: any time you do <code>(*ptr).my_field</code> the compiler will emit <code>GEP inbounds</code>. Have you ever wondered why the documentation for <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset">ptr::offset</a> and friends is so weird and complicated? Because they lower to <code>GEP inbounds</code> and need to follow its rules! <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset">ptr::wrapping_offset</a> is just <code>GEP</code> without the <code>inbounds</code>. And even <code>wrapping_offset</code> isn‚Äôt <em>actually</em> allowed to break provenance:</p>
<blockquote>
<p>Compared to <code>offset</code>, this method basically delays the requirement of staying within the same allocated object: <code>offset</code> is immediate Undefined Behavior when crossing object boundaries; <code>wrapping_offset</code> produces a pointer but still leads to Undefined Behavior if a pointer is dereferenced when it is out-of-bounds of the object it is attached to.</p>
</blockquote>
<h2 id="cheri" class="section-header"><a href="#cheri">1.3 CHERI</a></h2>
<p>Mea culpa, I spent years calling <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a> completely unshippable vaporware! I was pretty confident, but I‚Äôll eat my hat because <a href="https://www.arm.com/architecture/cpu/morello">ARM Morello actually built and shipped a full CHERI-based CPU</a>. Congratulations to everyone who worked on it!</p>
<p>So what is CHERI? I‚Äôm not going to get into the nitty-gritty details but roughly speaking it‚Äôs a 128-bit architecture. Well actually it‚Äôs 129-bit. Well actually it‚Äôs 64-bit. <em>Sorry what?</em></p>
<p>Ok so the whole Idea with CHERI is that it actually reifies and implements the ‚Äúsandboxing‚Äù model from the previous section. Every pointer is tagged with extra metadata that the hardware maintains and validates. If you ever break out of your sandbox the hardware will catch it and the OS will presumably kill your process.</p>
<p>I don‚Äôt know the full details of the encoding or metadata, but the part we care about is that each pointer contains a compressed <em>slice</em> (range of memory) that it is allowed to point into as well as the <em>actual</em> address that it points to. The slice is that pointer‚Äôs sandbox, and all pointers derived from it inherit that sandbox (or less). Whenever you access some memory, the hardware just checks that the pointer is still inside its sandbox.</p>
<p>This metadata isn‚Äôt cheap: pointers in CHERI are 128-bits wide, but the effective address space is still at most 64-bit (I don‚Äôt know the exact upper bound, all that matters is that addresses <em>fit</em> in 64-bit). Now 128-bit is <em>really</em> bloated, so in C(++) CHERI actually gets help from our old nemesis <a href="https://gankra.github.io/blah/rust-layouts-and-abis/#the-c-integer-hierarchy">The Wobbly C Interger Hierarchy</a>.</p>
<p>C makes a distinction between <code>intptr_t</code> (‚Äúa pointer-sized integer‚Äù) and <code>ptrdiff_t</code>/<code>size_t</code> (‚Äúoffset-sized integers‚Äù). Under CHERI, <code>intptr_t</code> is 128-bit and <code>ptrdiff_t</code>/<code>size_t</code> are 64-bit. It can do this because the address space is still only 64-bit, so anything that refers to offsets or sizes can still be 64-bit.</p>
<p>Ok so you might have two burning questions at this point: how on earth can this possible work if I can just scribble over a pointer and corrupt its metadata, and why did you say it‚Äôs actually 129-bit. As it turns out, those are the same question!</p>
<p>I find the best way to conceptualize this is to think of it like <a href="https://en.wikipedia.org/wiki/ECC_memory">ECC (Error Correction Code) RAM</a>. In ECC RAM, each RAM stick actually has more physically memory than it claims, because it‚Äôs transparently using that extra memory to correct or detect random bitflips. So there‚Äôs all this extra memory <em>somewhere</em> but as far as a compiler or programmer are concerned, the memory looks perfectly normal and doesn‚Äôt have any weird extra bits.</p>
<p>CHERI does the same thing, but the extra 129th bit the hardware is hiding from you is a ‚Äúmetadata is valid‚Äù bit. You see, to properly manipulate pointers in CHERI you need to access the memory/registers containing a pointer with specific instructions for that task. If you try to manipulate them some other way (say by memcpying random bytes over it), the hardware will disable the ‚Äúmetadata is valid‚Äù bit. Then if you try to use it <em>as</em> a pointer, the hardware will see your metadata can‚Äôt be trusted and fault/kill your process.</p>
<p>It‚Äôs friggin‚Äô neato!</p>
<p>(A lot of the issues we‚Äôll see with integrating Rust with CHERI will actually look a lot like issues with <em>segmented architectures</em>, but I have never used those so I will just be vaguely gesturing at them and handwaving. Just keep in mind that whenever I refer to CHERI, a similar argument <em>also</em> probably applies to segmenting. So if you care about segmented architectures, you might care about CHERI too!)</p>
<h1 id="problems" class="section-header"><a href="#problems">2 Problems</a></h1>
<p>Now let‚Äôs see how Rust‚Äôs current unsafe pointer APIs cause problems for all the background we‚Äôve seen above.</p>
<h2 id="integer-to-pointer-casts-are-the-devil" class="section-header"><a href="#integer-to-pointer-casts-are-the-devil">2.1 Integer-To-Pointer Casts Are The Devil</a></h2>
<p>Rust currently says this code is totally cool and fine:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Masking off a tag someone packed into a pointer:</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">my_ptr</span> <span class="kw">as</span> <span class="ident">usize</span>;
<span class="ident">addr</span> <span class="op">=</span> <span class="ident">addr</span> <span class="op">&amp;</span> <span class="op">!</span><span class="number">0x1</span>; 
<span class="kw">let</span> <span class="ident">new_ptr</span> <span class="op">=</span> <span class="ident">addr</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">T</span>;
<span class="kw-2">*</span><span class="ident">new_ptr</span> <span class="op">+</span><span class="op">=</span> <span class="number">10</span>;</code></pre></div>
<p>This is some pretty bog-standard code for messing with tagged pointers, what‚Äôs wrong with that?</p>
<p>Think about the background we just discussed. Think about Pointer Provenance. Think about CHERI.</p>
<p>üôÄ aAAaAAaaaAAaAAAAAA üôÄ</p>
<p>For this to <em>possibly</em> work with Pointer Provenance and Alias Analysis, that stuff must pervasively infect all integers on the assumption that they <em>might</em> be pointers. This is a huge pain in the neck for people who are trying to actually <a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/">formally define Rust‚Äôs memory model</a>, and for people who are <a href="https://github.com/rust-lang/miri">trying to build sanitizers for Rust that catch UB</a>. And I assure you it‚Äôs <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2676.pdf">just as much a headache for all the LLVM and C(++) people too</a>.</p>
<p>For this to <em>possibly</em> work with CHERI we need to make usize 128-bit (even though the address space is 64-bit) and always manipulate it with ‚Äúpointer instructions‚Äù on the assumption that it <em>might</em> be a pointer in the vein of intptr_t. Yes folks have tried running Rust under CHERI and <a href="https://nw0.github.io/cheri-rust.pdf">that‚Äôs exactly what they had to do</a>. It was, Not Good.</p>
<p>Unfortunately for CHERI, Rust actually <em>defines</em> <code>usize</code> to be the same size as a pointer, even though its primary role is to be an offset/size. This is a <em>very</em> reasonable assumption for mainstream platforms, but it runs afoul of CHERI (and segmented architectures)!</p>
<p>If you <em>don‚Äôt</em> make usize 128-bit and just try to make it the 64-bit ‚Äúaddress‚Äù portion, then <code>usize as *mut T</code> is a completely incoherent operation. Promoting an integer to a pointer (or what CHERI calls <em>a capability</em>) requires adding metadata to it. What metadata? What range is this random address possibly valid for? There is literally no way to answer that question!</p>
<p>Now you might be thinking ‚Äúok but pointer tagging is a super fundamental thing, are you saying we can‚Äôt do that anymore?‚Äù. Nope! You can totally still do tagging tricks, but you need to be a bit more careful about it. This is why CHERI actually <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf#page=28">introduces a special operation</a>: </p>
<div class="example-wrap"><pre class="language-C"><code>void* cheri_address_set(void* capability, vaddr_t address)</code></pre></div>
<p>This takes a valid pointer (capability) and an address, and creates a new pointer with the same metadata but the new address. <code>vaddr_t</code> is a new integer type that CHERI introduced which is morally equivalent to other ‚Äúaddress-space-sized‚Äù pointers like <code>size_t</code>, <code>ptrdiff_t</code>, etc.</p>
<p>Hey! That operation <em>also</em> looks really useful for provenance, doesn‚Äôt it? By associating our int-to-ptr operation with an existing pointer we are <em>reestablishing</em> the provenance chain of custody: the new pointer is derived from the old one, and compilers and memory-models can be happy! HMMMM‚Ä¶</p>
<h2 id="references-make-really-strong-assertions" class="section-header"><a href="#references-make-really-strong-assertions">2.2 References Make Really Strong Assertions</a></h2>
<p>In the grand old days of Rust 1.0, we were pretty optimistic about how fast-and-loose we could be with raw pointers. Well, ok we were actually pretty rigorous about pointers by most people‚Äôs standards. We largely enforced GEP inbounds semantics, required alignment everywhere, <a href="https://doc.rust-lang.org/nightly/nomicon/vec/vec-zsts.html">carved out how to work with ZSTs</a>, <a href="https://doc.rust-lang.org/nightly/nomicon/vec/vec-alloc.html">ensured that allocations can‚Äôt be larger than isize::MAX</a>, etc.</p>
<p>But what we played really fast and loose on was <em>aliasing</em> and <em>validity</em>. In Ye Olde conception of Rust, references were kinda just <em>conveniences</em>. Like yes they asserted many things, but not in a <em>compiler optimization</em> kinda way. Just in a ‚Äúthis API guarantees this‚Äù kinda way. We all vaguely knew we <em>wanted</em> the optimization-y stuff but no one had spent the energy to work that out.</p>
<p>These days, between <a href="https://github.com/rust-lang/unsafe-code-guidelines">unsafe-code-guidelines</a>, <a href="https://github.com/rust-lang/miri">miri</a> and <a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/">stacked borrows</a>, a lot of us have now put a lot of thought into this. Miri is especially useful because it lets us ‚Äúkick the tires‚Äù on actual code and check if the semantics we‚Äôre interested in are actually obeyed by real unsafe Rust code.</p>
<p>They Weren‚Äôt! This is why <a href="https://rust-unofficial.github.io/too-many-lists/fifth.html">the unsafe queue</a> in Learn Rust With Entirely Too Many Linked Lists abruptly comes to a halt for a 4000 word delve into miri and stacked borrows! Even something as boring as a linked queue in Ye Olde Rust had confusing and busted semantics.</p>
<p>(For real read that chapter if you want to understand stacked borrows, I‚Äôm not rehashing it here.)</p>
<p>The fundamental issue is that under our modern understanding of Rust, even <em>creating</em> a reference is making an extremely strong validity assertion and has side-effects on the ‚Äúborrow stack‚Äù which in turn changes which references are considered to invalidate or not. For a reference to <code>T</code> this potentially includes:</p>
<ul>
<li>The reference is aligned</li>
<li>The reference is non-null</li>
<li>The pointed-to-memory is allocated and has at least <code>size_of::&lt;T&gt;()</code> bytes.</li>
<li>If T has <a href="https://doc.rust-lang.org/nomicon/what-unsafe-does.html">invalid values</a>, the pointed-to-memory does not contain one.</li>
</ul>
<p>The upshot of all of this is that <em>generally</em> you should avoid mixing references and unsafe pointers. Unsafe code should <em>generally</em> provide a safe-referency-interface at its API boundary, and then internally drop the references and try to stay in unsafe pointer land. This way you minimize the strong assertions you make about your sketchy low-level data structures‚Äô memory.</p>
<p>Ok, simple enough, right?</p>
<h2 id="offsets-and-places-are-a-mess" class="section-header"><a href="#offsets-and-places-are-a-mess">2.3 Offsets And Places Are A Mess</a></h2>
<p>So you‚Äôre trying to be responsible and stay in unsafe pointer land and it‚Äôs time to offset a pointer. That‚Äôs easy, we have ptr::offset/add/sub for that! Let‚Äôs just offset to this struct‚Äôs field‚Ä¶ uh‚Ä¶ wait what‚Äôs that field‚Äôs offset?</p>
<p>Oh Rust just, doesn‚Äôt tell me that huh? Well maybe you can do something like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw-2">&amp;mut</span> (<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field</span></code></pre></div>
<p>Oh no wait that made a reference. Yes even if you immediately cast it to a raw pointer. How the heck do you take an address without creating a reference? Also is it actually fine for me to use a reference to initialize uninit memory? Sort of, sometimes.</p>
<p>This is a big confusing mess. For a long time we tried to have some kind of ‚Äú5-second rule‚Äù thing where if you converted the reference to a raw pointer ‚Äúfast enough‚Äù then it‚Äôs OK but that was pretty clearly untenable for a formal model (I advocated for it, it would have been nice!). So folks came up with <a href="https://github.com/rust-lang/rfcs/blob/master/text/2582-raw-reference-mir-operator.md">a proper RFC for raw addresses</a> and for a long time we‚Äôve had a hacky <a href="https://doc.rust-lang.org/stable/std/ptr/macro.addr_of.html">addr_of macro</a> that lets you do this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">addr_of!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field</span>)</code></pre></div>
<p>‚Ä¶yeah I hate it too.</p>
<p>And even that didn‚Äôt put the nail in the coffin. There was recently <a href="https://lucumr.pocoo.org/2022/1/30/unsafe-rust/">a post by a very experienced rust developer</a> that basically amounted to confused frustration at the current state of affairs with doing this stuff with <a href="https://doc.rust-lang.org/nomicon/unchecked-uninit.html">uninitialized memory</a>. Meanwhile the <em>actual</em> thing proposed in the RFC <a href="https://github.com/rust-lang/rust/issues/64490">has seemingly been stalled out for years</a> because the Experts on this stuff are themselves <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/319">confused by the corner-cases of addr_of</a>.</p>
<p>And to make it even worse, addr_of also makes it really hard to do a thing people <em>still</em> want which is static <a href="https://en.cppreference.com/w/cpp/types/offsetof">offsetof</a>.</p>
<p>It is my assertion that a lot of this boils down to two facts:</p>
<ul>
<li>Dereferencing Pointers Is Fake Nonsense</li>
<li><a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">Places</a> Are Extremely Confusing Magic (Rust‚Äôs term for lvalues)</li>
</ul>
<p>Like if we think about what ‚Äúdereferencing‚Äù a pointer is‚Ä¶ it‚Äôs actually nothing? Like dereferencing a pointer doesn‚Äôt actually <em>do</em> a thing. It puts you in ‚Äúplace expression‚Äù mode and lets you specify an offset to subfields/indices of the pointee, and then what <em>actually</em> happens is only specified at the end. e.g.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>(<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field1</span>.<span class="ident">field2</span>[<span class="ident">i</span>].<span class="ident">field4</span>;     <span class="comment">// load</span>
(<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field1</span>.<span class="ident">field2</span>[<span class="ident">i</span>].<span class="ident">field4</span> <span class="op">=</span> <span class="number">5</span>; <span class="comment">// store</span>
<span class="kw-2">&amp;</span>(<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field1</span>.<span class="ident">field2</span>[<span class="ident">i</span>].<span class="ident">field4</span>     <span class="comment">// offset (*maybe*)</span></code></pre></div>
<p>This is certainly <em>familiar</em> syntax but it‚Äôs genuinely also kind of magical in the exact same way autoderef is in Rust. That is to say, it makes a kind of sense and honestly you just don‚Äôt need to think about the fact that it‚Äôs happening <em>in safe Rust code</em> because you know the compiler has your back and will help out if anything goes wrong. But in unsafe Rust code? This stuff is way too fuzzy. I literally can‚Äôt tell if the indexing is into a slice or an inline array, or if any of those <code>.</code>s is dereferencing stuff implicitly.</p>
<p>(Also as far as memory-model goes, there‚Äôs actually some disagreement on whether dereferencing in-and-of-itself <em>actually</em> has no intrinsic meaning or if it does some validity assertions!)</p>
<p>As I said before, when you‚Äôre doing unsafe pointer stuff you want to <em>stay</em> in that mode. That is currently <em>impossible</em> with this place-expression design, because as soon as you deref you‚Äôre kinda in a weird twilight between safe and unsafe!</p>
<h1 id="solutions" class="section-header"><a href="#solutions">3 Solutions</a></h1>
<p>Alright and now here is where I start going off the rails and proposing wild overhauls to Rust with almost no regard for ‚Äúparsing‚Äù.</p>
<h2 id="distinguish-pointers-and-addresses" class="section-header"><a href="#distinguish-pointers-and-addresses">3.1 Distinguish Pointers And Addresses</a></h2>
<p>The connection between <code>usize</code> and pointers needs to be completely overhauled, and I would take a chainsaw to it (using proper <a href="https://doc.rust-lang.org/edition-guide/editions/index.html">editions and deprecation periods</a>).</p>
<p>Here‚Äôs the high level look at our tasteful chainsawing:</p>
<ul>
<li>Define a distinction between a <em>pointer</em> and an <em>address</em></li>
<li>Redefine usizes as address-sized, which is &lt;= pointer-sized (and usually ==)</li>
<li>Define <code>ptr.addr() -&gt; usize</code> and <code>ptr.with_addr(usize) -&gt; ptr</code> methods</li>
<li>Deprecate <code>usize as ptr</code> and <code>ptr as usize</code></li>
</ul>
<h3 id="redefining-usize" class="section-header"><a href="#redefining-usize">3.1.1 Redefining usize</a></h3>
<p>First off, those definitions. A pointer is still a pointer as we know it, but we now acknowledge that it points into a specific <em>address space</em>. A pointer also contains an <em>address</em> which is conceptually an offset into this address space. </p>
<p>(For all major architectures <em>and</em> CHERI there is only one address space as far as I‚Äôm concerned, but it‚Äôs potentially worth opening the door for properly talking about pointers in segmented architectures here. Although regarding x64‚Äôs TLS (Thread Local Storage) implementation as a separate address space from the perspective of a thread is probably more honest.)</p>
<p>A usize is large enough to contain all addresses for all address spaces on that platform. For major architectures, that means a <code>usize</code> is still pointer-sized. For CHERI, that means <code>usize</code> can (and should) be a <code>u64</code> and is equivalent to CHERI‚Äôs <code>vaddr_t</code>. To keep things tolerable I think it would be reasonable to still require that <code>usize</code>/<code>isize</code> is the same as <code>size_t</code> and <code>ptrdiff_t</code> in the target‚Äôs ABI. </p>
<p>(Again hopefully this generic definition is useful for segmenting, although I‚Äôve heard nasty rumors of segmented platforms that actually decouple <code>size_t</code> and <code>ptrdiff_t</code> which is horrible and maybe still something we don‚Äôt want to support.)</p>
<p>As a result, someone writing <em>maximally portable</em> Rust must now replace their assumptions:</p>
<p><code>size_of::&lt;usize&gt;() == size_of::&lt;*mut u8&gt;()</code></p>
<p>is now:</p>
<p><code>size_of::&lt;usize&gt;() &lt;= size_of::&lt;*mut u8&gt;()</code></p>
<p>There should probably be a <code>cfg(target_address_size_is_pointer_size)</code> or something to allow people to specify software is incompatible with <em>weird</em> platforms where the strict equality doesn‚Äôt hold.</p>
<p>I don‚Äôt think Rust needs to define a moral equivalent to <code>intptr_t</code>, if the new casting APIs work out as well as I hope ‚Äì <code>*mut ()</code> is already <code>intptr_t</code> for most valid purposes. As far as I‚Äôm aware the <code>intptr_t</code> shenanigans that CHERI does are less ‚Äúdefinitely good and desirable‚Äù and more ‚Äúawful hacks to get old code working‚Äù. That said, people keep vaguely mentioning memory-mapped hardware as a place where this might be important, but that is outside my domain of expertese (and clearly needs special segment/provenance/capability handling <em>anyway</em>).</p>
<h3 id="replacing-pointer-integer-casts" class="section-header"><a href="#replacing-pointer-integer-casts">3.1.2 Replacing Pointer-Integer Casts</a></h3>
<p>Next off, replacing casts with methods. All casts from raw pointers to/from integers are to be deprecated. This <em>primarily</em> means for isize/usize but for whatever reason rust lets you do <code>ptr as u8</code> too and that is even <em>more</em> gibberish.</p>
<p>The following new methods would be added:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Ditto for `*const T`</span>

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="question-mark">?</span><span class="ident">Sized</span><span class="op">&gt;</span> <span class="kw-2">*mut</span> <span class="ident">T</span> {
    <span class="doccomment">/// Gets the &quot;address&quot; portion of the pointer.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// On most platforms this is a no-op, as the pointer is just an address,</span>
    <span class="doccomment">/// and is equivalent to the deprecated `ptr as usize` cast.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// On more complicated platforms like CHERI and segmented architectures,</span>
    <span class="doccomment">/// this may remove some important metadata. See [`with_addr`][] for</span>
    <span class="doccomment">/// details on this distinction and why it&#39;s important.</span>
    <span class="kw">fn</span> <span class="ident">addr</span>(<span class="self">self</span>) -&gt; <span class="ident">usize</span>;

    <span class="doccomment">/// Creates a new pointer with the given address.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This replaces the deprecated `usize as ptr` cast, which had</span>
    <span class="doccomment">/// fundamentally broken semantics because it couldn&#39;t restore </span>
    <span class="doccomment">/// *segment* and *provenance*.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// A pointer semantically has 3 pieces of information associated with it:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * Segment: The address-space it is part of.</span>
    <span class="doccomment">/// * Provenance: An allocation (slice) that it is allowed to access.</span>
    <span class="doccomment">/// * Address: The actual address it points at.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The compiler and hardware need to properly understand all 3 of these</span>
    <span class="doccomment">/// values at all times to properly execute your code.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Segment and Provenance are implicitly defined by *how* a pointer is</span>
    <span class="doccomment">/// constructed and generally propagates verbatim to all derived pointers.</span>
    <span class="doccomment">/// It is therefore *impossible* to convert an address into a pointer</span>
    <span class="doccomment">/// on its own, because there is no way to know what its segment and</span>
    <span class="doccomment">/// provenance should be.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// By introducing a &quot;representative&quot; pointer into the process we can</span>
    <span class="doccomment">/// properly construct a new pointer with *its* segment and provenance,</span>
    <span class="doccomment">/// just as any other derived pointer would. This is equivalent to</span>
    <span class="doccomment">/// `offset`ting the given pointer to that address, so it needs to still</span>
    <span class="doccomment">/// be legal to perform that operation!</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Example</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Here is an example of how to properly use this API to mess around</span>
    <span class="doccomment">/// with tagged pointers. Here we have a tag in the lowest bit:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```rust,ignore</span>
    <span class="doccomment">/// let my_tagged_ptr: *mut T = ...;</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// // Get the address and do whatever bit tricks we like</span>
    <span class="doccomment">/// let addr = my_tagged_ptr.addr();</span>
    <span class="doccomment">/// let has_tag = (addr &amp; 0x1) != 0;</span>
    <span class="doccomment">/// let real_addr = addr &amp; !0x1;</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// // Reconstitute a pointer with the new address and use it</span>
    <span class="doccomment">/// let my_untagged_ptr = my_tagged_ptr.with_addr(real_addr);</span>
    <span class="doccomment">/// *my_untagged_ptr = ...;</span>
    <span class="doccomment">/// ```</span>
    <span class="kw">fn</span> <span class="ident">with_addr</span>(<span class="self">self</span>, <span class="ident">addr</span>: <span class="ident">usize</span>) -&gt; <span class="self">Self</span>;
}</code></pre></div>
<p>Deprecating the casts may seem extreme, but as far as I‚Äôm concerned this is the exact same situation as <a href="https://gankra.github.io/blah/initialize-me-maybe/">when we deprecated mem::uninitialized</a>. The design of these casts is fundamentally broken under both Pointer Provenance and CHERI. Everyone needs to use a better design that actually has a coherent meaning.</p>
<p>Now <em>technically</em> you could keep <code>ptr as usize</code> but I think it‚Äôs better to replace both for several reasons:</p>
<ul>
<li>Getting a deprecation warning for both sides of the cast raises a big red flag to <em>everyone</em> doing anything even vaguely dubious with a usize that they have some thinking to do.</li>
<li>You can‚Äôt hang documentation off of casts. As I hope this post demonstrates, int-ptr stuff is extremely subtle and hairy, and deserves a lot of detailed documentation!</li>
<li><code>ptr as usize</code> is horribly clunky in practice so destroying it is honestly a mercy. </li>
<li>Straight-up symmetry/aesthetics. It‚Äôs weird to only have one!</li>
</ul>
<p>As the documentation notes, the new with_addr method allows us to reconstitute many things:</p>
<ul>
<li>What segment the address goes to (hopefully)</li>
<li><em>Provenance</em> for the purposes of memory models / alias analysis</li>
<li><em>Metadata</em> for the purposes of CHERI (but this is just a reification of provenance)</li>
</ul>
<p>‚Ä¶that it! It just fixes the issue. That‚Äôs all you need to fix provenance and CHERI! (And maybe also support segmenting.)</p>
<p>(In reality there might need to be some more special APIs added to satisfy the existing Jank uses of ptr-int conversions, but that really needs to be shaken out on crates.io and with the community.)</p>
<blockquote>
<p>Unclear detail: is get_addr/with_addr also necessary/useful for <a href="https://www.qualcomm.com/media/documents/files/whitepaper-pointer-authentication-on-armv8-3.pdf">ARMv8.3 Pointer Authentication</a>? This is a technology that Apple ships and involves some pointers getting signed/obfuscated to make it a bit harder to do memory-safety exploits. I haven‚Äôt looked into it enough to know what level of abstraction this ‚Äúleaks‚Äù into. I just know about it because it shows up in minidumps and we have to <a href="https://github.com/rust-minidump/rust-minidump/blob/7eed71e4075e0a81696ccc307d6ac68920de5db5/minidump-processor/src/stackwalker/arm64.rs#L252">hackily try to strip it out</a>.</p>
</blockquote>
<h2 id="fixing-places-and-offsets" class="section-header"><a href="#fixing-places-and-offsets">3.2 Fixing Places and Offsets</a></h2>
<p>Ok here‚Äôs a two-part combo of syntactic niceties to make it a lot easier to work with unsafe pointers.</p>
<h3 id="path-offset-syntax" class="section-header"><a href="#path-offset-syntax">3.2.1 Path Offset Syntax</a></h3>
<p>Hey Did You Know Rust <a href="https://github.com/rust-lang/reference/pull/1149">Never Actually</a> Removed Tilde (<code>~</code>) From <a href="https://doc.rust-lang.org/nightly/reference/tokens.html#punctuation">The Syntax</a>?</p>
<p>Did you also know that <code>~</code> was one of the things that originally drew me to messing around with Rust back in like 2014, and that I was very sad to learn that it was already being removed?</p>
<p>Well today I get my justice. Today I return <code>~</code> to its position of glory that is <em>deserved</em>.</p>
<p>I am almost <em>certain</em> that I‚Äôm going to run afoul of parser ambiguities somewhere here but hey this isn‚Äôt a real RFC and I get to make the rules. Maybe it works fine. Maybe it can be fixed in an edition. Let‚Äôs find out!</p>
<p>Here is my grand vision that will solve all of Rust‚Äôs woes around ‚Äústaying in unsafe pointer mode‚Äù and just generally dealing with offsets: If you write <code>~</code> instead of <code>.</code> it always does a raw pointer offset.</p>
<p>That‚Äôs it. Ok that‚Äôs not just it, but that‚Äôs basically the whole idea. Let‚Äôs start with some examples:</p>

<div class='information'><div class='tooltip ignore'>‚ìò</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="comment">// Some non-POD type with some fields</span>
<span class="kw">struct</span> <span class="ident">MyType</span> {
    <span class="ident">field1</span>: <span class="ident">bool</span>,
    <span class="ident">field2</span>: <span class="ident">Vec</span>,
    <span class="ident">field3</span>: [<span class="ident">u32</span>; <span class="number">4</span>],
}

<span class="comment">// Using ~ syntax on a raw pointer to cleanly initialize MaybeUninit</span>
<span class="kw">let</span> <span class="ident">init</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">uninit</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">MyType</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
    <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">uninit</span>.<span class="ident">as_mut_ptr</span>();

    <span class="ident">ptr</span>~<span class="ident">field1</span>.<span class="ident">write</span>(<span class="bool-val">true</span>);
    <span class="ident">ptr</span>~<span class="ident">field2</span>.<span class="ident">write</span>(<span class="macro">vec!</span>[]);
    <span class="ident">ptr</span>~<span class="ident">field3</span>~[<span class="number">0</span>].<span class="ident">write</span>(<span class="number">7</span>);
    <span class="ident">ptr</span>~<span class="ident">field3</span>~[<span class="number">1</span>].<span class="ident">write</span>(<span class="number">2</span>);
    <span class="ident">ptr</span>~<span class="ident">field3</span>~[<span class="number">2</span>].<span class="ident">write</span>(<span class="number">12</span>);
    <span class="ident">ptr</span>~<span class="ident">field3</span>~[<span class="number">3</span>].<span class="ident">write</span>(<span class="number">88</span>);

    <span class="ident">uninit</span>.<span class="ident">assume_init</span>();
};</code></pre></div>
<p>Yes <code>~[idx]</code> is a bit wonky but it‚Äôs <em>clear</em> and <em>concise</em> and that‚Äôs the most important thing. Note that this is what you would have to do in today‚Äôs Rust</p>

<div class='information'><div class='tooltip ignore'>‚ìò</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">let</span> <span class="ident">init</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">uninit</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">MyType</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
    <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">uninit</span>.<span class="ident">as_mut_ptr</span>();

    <span class="macro">addr_of!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field1</span>).<span class="ident">write</span>(<span class="bool-val">true</span>);
    <span class="macro">addr_of!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field2</span>).<span class="ident">write</span>(<span class="macro">vec!</span>[]);
    <span class="macro">addr_of!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field3</span>[<span class="number">0</span>]).<span class="ident">write</span>(<span class="number">7</span>);
    <span class="macro">addr_of!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field3</span>[<span class="number">1</span>]).<span class="ident">write</span>(<span class="number">2</span>);
    <span class="macro">addr_of!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field3</span>[<span class="number">2</span>]).<span class="ident">write</span>(<span class="number">12</span>);
    <span class="macro">addr_of!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field3</span>[<span class="number">3</span>]).<span class="ident">write</span>(<span class="number">88</span>);

    <span class="ident">uninit</span>.<span class="ident">assume_init</span>();
};</code></pre></div>
<p>Or if you‚Äôre being clever and trying to leverage the fact that POD types can be initialized without <code>write</code>:</p>

<div class='information'><div class='tooltip ignore'>‚ìò</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">let</span> <span class="ident">init</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">uninit</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">MyType</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
    <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">uninit</span>.<span class="ident">as_mut_ptr</span>();

    (<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field1</span> <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="macro">addr_of!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field2</span>).<span class="ident">write</span>(<span class="macro">vec!</span>[]);
    (<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field3</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">7</span>;
    (<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field3</span>[<span class="number">1</span>] <span class="op">=</span> <span class="number">2</span>;
    (<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field3</span>[<span class="number">2</span>] <span class="op">=</span> <span class="number">12</span>;
    (<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">field3</span>[<span class="number">3</span>] <span class="op">=</span> <span class="number">88</span>;

    <span class="ident">uninit</span>.<span class="ident">assume_init</span>();
};</code></pre></div>
<p>What I <em>really</em> like about the ~ version is that:</p>
<ul>
<li>
<p>It‚Äôs all postfix just like we learned is Very Good And Nice with <code>.await</code>! Just look at how nasty <code>addr_of!((*ptr).field2).write(vec![])</code> is!</p>
</li>
<li>
<p>Each <code>~</code> can be evaluated individually ‚Äì there‚Äôs no need for the language to enter a ‚Äúmode‚Äù where it‚Äôs evaluating a ‚Äúplace‚Äù as far as the programmer is concerned. (The compiler is free to do it that way behind the scenes, you just don‚Äôt need to know about it.)</p>
</li>
<li>
<p>Because you <em>stay</em> in raw-pointer mode, it‚Äôs much less painful to reach for things like the <code>read</code> and <code>write</code> methods. This makes it just as easy to do more complicated things like <code>read_volatile</code> and doesn‚Äôt encourage you to be ‚Äúclever‚Äù and lean on the fact that things happen to be POD. All <code>write</code>s is a very nice kind of <em>mindlessly right</em>.</p>
</li>
<li>
<p>You never have to worry about accidentally tripping over autoderef or any other thing that is nice for safe code but a huge hazard for unsafe code.</p>
</li>
<li>
<p>By getting rid of the <code>(*ptr).</code> ‚Äúsyntactic salt‚Äù, programmers are motivated to move to the nicer and more robust new syntax. Yes I <em>really</em> think this syntax is nice! It‚Äôs certainly better than <code>-&gt;</code> in C!</p>
</li>
</ul>
<p>We can also conceptually extend this syntax so it‚Äôs allowed on types and computes a const offsetof in usize bytes. Note that unlike <code>~</code> on values, this syntax can‚Äôt operate ‚Äúone step at a time‚Äù and needs to be evaluated more like ‚Äúpath expressions‚Äù. Magic is less concerning in this context because any mistake is a compiler error. Here‚Äôs how you might use it to do more ‚Äúsketchy‚Äù offsets:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Using ~ on a type for const offsetof (usize byte offset)</span>
<span class="kw">const</span> <span class="ident">MY_FIELD_OFFSET</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">MyType</span>~<span class="ident">field1</span>~[<span class="number">2</span>];

<span class="comment">// If you want this to be syntactically distinct,</span>
<span class="comment">// then we can require some amount of `::`</span>
<span class="comment">//</span>
<span class="comment">// Option A: MyType::~field~[2];</span>
<span class="comment">// Option B: MyType::~field::~[2];</span>

<span class="comment">// A pointer to some sketchy memory</span>
<span class="comment">// !!IMPORTANT THAT THIS IS IN BYTES!!</span>
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*mut</span> <span class="ident">u8</span> <span class="op">=</span> ...;

<span class="comment">// We&#39;re doing evil things, so wrapping_add</span>
<span class="kw">let</span> <span class="ident">field_ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="ident">MY_FIELD_OFFSET</span>) <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">FieldType</span>;
<span class="comment">// use field_ptr somehow...</span></code></pre></div>
<p>I am less passionate about the const offsetof stuff but it <em>seems</em> like it could be made to work and I know people really want that stuff. </p>
<p>Additional notes:</p>
<ul>
<li>It should propagate <code>*const</code> vs <code>*mut</code></li>
<li>I don‚Äôt know if it makes sense or is a good idea but maybe you could use <code>~</code> on actual references and non-references (int, struct, array, tuple‚Ä¶) and not just raw pointers?
<ul>
<li>If so, it may be desirable to support <code>val~self</code> as a nicer postfix way to write <code>&amp;mut val as *mut _</code> but this is messy if you support both references and non-references since that would be potentially ambiguous as to whether you want a raw-pointer-to-ref or just raw-pointer.</li>
</ul>
</li>
</ul>
<h3 id="postfix-deref" class="section-header"><a href="#postfix-deref">3.2.2 Postfix Deref</a></h3>
<p>This is the least well-formed idea in here, but as long as we‚Äôre cleaning up raw pointers with nice and clean postfix syntax it would be <em>really</em> nice if we also had postfix deref. Note that because of the whole ‚Äúcreating a reference does magic assertions‚Äù thing you <em>can‚Äôt</em> provide something like a <code>deref(self) -&gt; &amp;T</code> method that actually has the same semantics as <code>*ptr</code>! Dereferencing raw pointers <em>must</em> have first-class syntax.</p>
<p>Consider for instance trying to access some multiply-indirected value.</p>
<p>Today:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">addr_of!</span>((<span class="kw-2">*</span>(<span class="kw-2">*</span>(<span class="kw-2">*</span><span class="ident">ptr1</span>).<span class="ident">field1</span>.<span class="ident">ptr2</span>).<span class="ident">ptr3</span>).<span class="ident">field4</span>).<span class="ident">read</span>()</code></pre></div>
<p>With offset syntax:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>(<span class="kw-2">*</span>(<span class="kw-2">*</span><span class="ident">ptr1</span>~<span class="ident">field1</span>~<span class="ident">ptr2</span>)~<span class="ident">ptr3</span>)~<span class="ident">field4</span>.<span class="ident">read</span>()</code></pre></div>
<p>With offset syntax and reads (remember, we‚Äôre staying in pointer mode, so <code>ptr2.read()</code> is loading <code>ptr2</code> from memory, so we can actually keep just using <code>~</code> syntax):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">ptr1</span>~<span class="ident">field1</span>~<span class="ident">ptr2</span>.<span class="ident">read</span>()~<span class="ident">ptr3</span>.<span class="ident">read</span>()~<span class="ident">field4</span>.<span class="ident">read</span>()</code></pre></div>
<p>With postfix deref:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Most obvious syntax, but likely ambiguous in current Rust</span>
<span class="ident">ptr1</span>~<span class="ident">field1</span>~<span class="ident">ptr2</span>.<span class="kw-2">*</span>~<span class="ident">ptr3</span>.<span class="kw-2">*</span>~<span class="ident">field4</span>.<span class="ident">read</span>()

<span class="comment">// Potentially viable alternative</span>
<span class="ident">ptr1</span>~<span class="ident">field1</span>~<span class="ident">ptr2</span>~<span class="kw-2">*</span>~<span class="ident">ptr3</span>~<span class="kw-2">*</span>~<span class="ident">field4</span>.<span class="ident">read</span>()</code></pre></div>
<p>(I think I independently came up with this <code>.*</code> syntax but I was very happy to learn that Zig <a href="https://ziglang.org/documentation/master/#Pointers">actually has it</a>, and <code>ptr.* += 1</code> is valid Zig syntax!)</p>
<p>The ambiguity issue with <code>.*</code> in Rust is that <code>1.</code> is a valid float literal, so stuff like <code>1. * 1.</code> is valid syntax and dangerously close to <code>1.*.1</code>. I certainly can imagine nasty ambiguities!</p>
<p>One nice thing about the <code>~</code> syntax is that because unary <code>*</code> already binds pretty weakly (which is why we need to do <code>(*ptr).field</code>), if you only need to do one deref, it‚Äôs as clean as using normal references:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw-2">*</span><span class="ident">ptr</span>~<span class="ident">field1</span>~<span class="ident">field2</span> <span class="op">=</span> <span class="number">5</span>;</code></pre></div>
<p>So actually the more I write this section the less I‚Äôm feeling the <em>need</em> for postfix deref, but in my heart-of-hearts I still want it.</p>
<p>Oh also you could imagine wanting <code>.&amp;</code> and <code>.&amp;mut</code> but similar syntax messes probably apply.</p>
<h1 id="thats-all" class="section-header"><a href="#thats-all">4 That‚Äôs All!</a></h1>
<p>Jesus that was a lot.</p>
<p>I think about unsafe pointers in Rust a lot.</p>
<p>I wrote this all in one sitting and I really need dinner.</p>
<p>Head empty only pointers.</p>

    </article>

<footer id="footer">

</footer>

</body>
</html>